<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VSPORT Elemző Motor - ADMIN</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f1f5f9; }
        .btn-hover:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }
        .card-hover:hover { transform: scale(1.01); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08); }
        .loader { width: 24px; height: 24px; border: 3px solid #FFF; border-bottom-color: transparent; border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite; }
        .poisson-card { border: 2px solid #38bdf8; background-color: #0c3355; }
        input[type=range]::-webkit-slider-thumb { background-color: #38bdf8; }
        input[type=range]::-moz-range-thumb { background-color: #38bdf8; }
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        .outcome-homeWin { background-color: #e8f5f9; border-left: 4px solid #4caf50; }
        .outcome-awayWin { background-color: #ffebee; border-left: 4px solid #f44336; }
        .outcome-draw { background-color: #fff3e0; border-left: 4px solid #ff9800; }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>

<body class="text-slate-800 p-4">

    <main id="app-page" class="w-full max-w-4xl bg-white rounded-2xl shadow-lg border border-gray-200 p-6 space-y-6 mx-auto">
        <div class="flex flex-col sm:flex-row justify-between items-start gap-4">
             <div class="text-left">
                 <h1 class="text-2xl md:text-3xl font-bold text-slate-900">VSport Elemző Motor</h1>
                 <p id="app-welcome-user" class="text-slate-500 mt-1">Bejelentkezve: <span class="font-bold text-purple-600">krisztian</span></p>
             </div>
             <div class="text-left sm:text-right space-y-2 w-full sm:w-auto">
                 <button id="open-stats-btn" class="bg-blue-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 btn-hover hover:bg-blue-700 flex items-center space-x-2 text-sm">
                   <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z" /></svg>
                   <span>Statisztika</span>
                 </button>
             </div>
        </div>

        <!-- Control Panel -->
        <div class="bg-gray-800 text-white p-5 rounded-xl border border-gray-700 space-y-4">
            <h2 class="text-lg font-semibold text-center">Bemeneti Adatok és Kalibráció</h2>
            <div id="ai-panel">
                <details open>
                    <summary class="font-semibold text-sky-300 cursor-pointer py-2">Mérkőzés Adatok</summary>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-4 pt-2">
                        <input type="text" id="home-team-input" placeholder="Hazai csapat" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                        <input type="text" id="away-team-input" placeholder="Vendég csapat" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                        <input type="text" inputmode="decimal" id="home-odd-input" placeholder="Hazai (1)" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                        <input type="text" inputmode="decimal" id="draw-odd-input" placeholder="Döntetlen (X)" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                        <input type="text" inputmode="decimal" id="away-odd-input" placeholder="Vendég (2)" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                    </div>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2">
                         <input type="text" inputmode="decimal" id="over-25-odd-input" placeholder="Over 2.5 Odds" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                         <input type="text" inputmode="decimal" id="under-25-odd-input" placeholder="Under 2.5 Odds" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                         <input type="text" inputmode="decimal" id="btts-yes-odd-input" placeholder="BTTS Igen Odds" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                         <input type="text" inputmode="decimal" id="btts-no-odd-input" placeholder="BTTS Nem Odds" class="ai-input w-full px-3 py-2 text-sm rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-sky-400 text-white">
                     </div>
                </details>

                <details class="mt-2">
                    <summary class="font-semibold text-sky-300 cursor-pointer py-2">Modell Finomhangolása</summary>
                      <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 text-sm pt-2">
                          <!-- Left Side: Sliders -->
                          <div class="space-y-4">
                              <div>
                                  <label for="rho-slider" class="block mb-1 text-gray-300">Dixon-Coles (ρ): <span id="rho-value">-0.15</span></label>
                                  <input id="rho-slider" type="range" min="-0.5" max="0.5" step="0.01" value="-0.15" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer ai-input">
                              </div>
                              <div>
                                  <label for="lambda3-slider" class="block mb-1 text-gray-300">Korreláció (λ3): <span id="lambda3-value">0.10</span></label>
                                  <input id="lambda3-slider" type="range" min="0" max="0.5" step="0.01" value="0.1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer ai-input">
                              </div>
                               <div>
                                  <label for="mixture-slider" class="block mb-1 text-gray-300">Preset Boost: <span id="mixture-value">10%</span></label>
                                  <input id="mixture-slider" type="range" min="0" max="1" step="0.01" value="0.1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer ai-input">
                              </div>
                               <div>
                                    <label for="margin-slider" class="block mb-1 text-gray-300">Manuális Margin: <span id="margin-value">5.0%</span></label>
                                    <input id="margin-slider" type="range" min="0" max="0.2" step="0.001" value="0.05" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer ai-input">
                               </div>
                          </div>
                          <!-- Right Side: Autofit -->
                          <div class="flex flex-col items-center justify-center bg-gray-700/50 p-3 rounded-lg space-y-2">
                               <div class="w-full flex gap-2">
                                   <button id="autofit-full-btn" class="w-full bg-sky-600 text-white font-bold py-2 px-2 rounded-lg btn-hover text-xs hover:bg-sky-700">Auto-Fit (Teljes)</button>
                                   <button id="autofit-recent-btn" class="w-full bg-sky-700 text-white font-bold py-2 px-2 rounded-lg btn-hover text-xs hover:bg-sky-800">Auto-Fit (Friss)</button>
                               </div>
                               <button id="drift-check-btn" class="w-full bg-purple-600 text-white font-bold py-2 px-3 rounded-lg btn-hover hover:bg-purple-700 text-sm">Drift Ellenőrzés</button>
                               <p id="autofit-status" class="text-xs font-semibold h-4 mt-1 text-center"></p>
                          </div>
                      </div>
                </details>
                 <div id="ai-result" class="pt-4 min-h-[400px]"></div>
            </div>
        </div>
        
        <div id="database-section">
            <h2 class="text-xl font-bold text-slate-800 mb-4">Meccs Adatbázis</h2>
            <div id="log-list" class="space-y-3"></div>
        </div>
    </main>

    <!-- Modal Container -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-gray-800 text-white w-full max-w-2xl rounded-xl shadow-2xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h3 id="modal-title" class="text-lg font-bold text-sky-300">Modal Title</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
            </div>
            <div id="modal-content" class="p-6 space-y-4 max-h-[70vh] overflow-y-auto"></div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- APP ELEMENTS ---
    const homeTeamInput = document.getElementById('home-team-input');
    const awayTeamInput = document.getElementById('away-team-input');
    const homeOddInput = document.getElementById('home-odd-input');
    const drawOddInput = document.getElementById('draw-odd-input');
    const awayOddInput = document.getElementById('away-odd-input');
    const rhoSlider = document.getElementById('rho-slider');
    const lambda3Slider = document.getElementById('lambda3-slider');
    const mixtureSlider = document.getElementById('mixture-slider');
    const marginSlider = document.getElementById('margin-slider');
    const rhoValue = document.getElementById('rho-value');
    const lambda3Value = document.getElementById('lambda3-value');
    const mixtureValue = document.getElementById('mixture-value');
    const marginValue = document.getElementById('margin-value');
    const aiResultDiv = document.getElementById('ai-result');
    const autofitFullBtn = document.getElementById('autofit-full-btn');
    const autofitRecentBtn = document.getElementById('autofit-recent-btn');
    const driftCheckBtn = document.getElementById('drift-check-btn');
    const autofitStatus = document.getElementById('autofit-status');
    const modalContainer = document.getElementById('modal-container');
    const modalTitle = document.getElementById('modal-title');
    const modalContent = document.getElementById('modal-content');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const openStatsBtn = document.getElementById('open-stats-btn');
    const logListDiv = document.getElementById('log-list');

    // --- APP STATE ---
    const initialLogs = [ { id: 1, name: "Chelsea - West Ham", home: 1.50, draw: 4.50, away: 5.50, homeScore: 5, awayScore: 0, outcome: "homeWin" }, { id: 2, name: "Liverpool - Tottenham", home: 1.45, draw: 4.80, away: 6.00, homeScore: 4, awayScore: 2, outcome: "homeWin" }, { id: 3, name: "Manchester City - Manchester United", home: 1.35, draw: 5.50, away: 7.50, homeScore: 4, awayScore: 0, outcome: "homeWin" }, { id: 4, name: "Arsenal - Fulham", home: 1.20, draw: 6.50, away: 12.00, homeScore: 3, awayScore: 1, outcome: "homeWin" }, { id: 5, name: "Crystal Palace - Newcastle", home: 2.80, draw: 3.30, away: 2.50, homeScore: 1, awayScore: 1, outcome: "draw" }, { id: 6, name: "Real Madrid - Barcelona", home: 1.80, draw: 3.90, away: 4.00, homeScore: 3, awayScore: 2, outcome: "homeWin" }, { id: 7, name: "Bayern München - Dortmund", home: 1.55, draw: 4.75, away: 5.00, homeScore: 4, awayScore: 1, outcome: "homeWin" }, { id: 8, name: "PSG - Lyon", home: 1.40, draw: 5.00, away: 7.00, homeScore: 4, awayScore: 1, outcome: "homeWin" }, { id: 9, name: "Inter - Milan", home: 2.00, draw: 3.50, away: 3.60, homeScore: 2, awayScore: 2, outcome: "draw" }, { id: 10, name: "Juventus - Roma", home: 1.90, draw: 3.40, away: 4.20, homeScore: 1, awayScore: 0, outcome: "homeWin" }, { id: 11, name: "Manchester United - Liverpool", home: 3.20, draw: 3.80, away: 2.10, homeScore: 2, awayScore: 2, outcome: "draw" }, { id: 12, name: "Fulham - Manchester City", home: 9.00, draw: 5.50, away: 1.30, homeScore: 0, awayScore: 4, outcome: "awayWin" }, { id: 13, name: "Tottenham - Arsenal", home: 2.90, draw: 3.60, away: 2.30, homeScore: 2, awayScore: 3, outcome: "awayWin" }, { id: 14, "name": "West Ham - Liverpool", "home": 4.5, "draw": 4.3, "away": 1.65, "homeScore": 2, "awayScore": 2, "outcome": "draw" }, { id: 15, "name": "Aston Villa - Chelsea", "home": 2.2, "draw": 3.6, "away": 3.0, "homeScore": 2, "awayScore": 2, "outcome": "draw" } ];
    let logs = [];
    let predictionsLog = [];
    let analysisTimeout;

    // --- BIVARIATE POISSON MODEL (DIXON-COLES) ---
    const AI_SYSTEM = {
        GENERATIVE_CORE: {
            _factorials: [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880],
            _factorial(n) { return this._factorials[n] || 1; },
            
            _bivariantPoisson(i, j, lambda1, lambda2, lambda3) {
                let prob = 0;
                const max_k = Math.min(i, j);
                for (let k = 0; k <= max_k; k++) {
                    prob += (Math.pow(lambda1, i - k) / this._factorial(i - k)) * (Math.pow(lambda2, j - k) / this._factorial(j - k)) * (Math.pow(lambda3, k) / this._factorial(k));
                }
                return prob * Math.exp(-(lambda1 + lambda2 + lambda3));
            },

            _tau(i, j, rho) {
                if (i === 0 && j === 0) return 1 - (rho * 2);
                if (i === 1 && j === 0) return 1 + rho;
                if (i === 0 && j === 1) return 1 + rho;
                if (i === 1 && j === 1) return 1 - rho;
                return 1;
            },

            run(homeTeam, awayTeam, rho, lambda3Corr, mixtureRatio, dataSource = logs) {
                const MIN_LOGS = 5, MIN_TEAM_LOGS = 1;
                if (dataSource.length < MIN_LOGS) return { error: `Nem elegendő adat (minimum ${MIN_LOGS} meccs szükséges).` };

                const homeLogs = dataSource.filter(l => l.name.toLowerCase().includes(homeTeam.toLowerCase()));
                const awayLogs = dataSource.filter(l => l.name.toLowerCase().includes(awayTeam.toLowerCase()));
                if (homeLogs.length < MIN_TEAM_LOGS || awayLogs.length < MIN_TEAM_LOGS) return { error: `Nincs elég adat a csapathoz (minimum ${MIN_TEAM_LOGS} meccs szükséges).` };
                
                const liga_home_avg = dataSource.reduce((s, l) => s + l.homeScore, 0) / dataSource.length;
                const liga_away_avg = dataSource.reduce((s, l) => s + l.awayScore, 0) / dataSource.length;

                const home_attack_str = (homeLogs.reduce((s, l) => s + (l.name.toLowerCase().startsWith(homeTeam.toLowerCase()) ? l.homeScore : l.awayScore), 0) / homeLogs.length) / liga_home_avg;
                const away_attack_str = (awayLogs.reduce((s, l) => s + (l.name.toLowerCase().includes(awayTeam.toLowerCase()) ? (l.name.toLowerCase().startsWith(awayTeam.toLowerCase()) ? l.homeScore : l.awayScore) : l.awayScore), 0) / awayLogs.length) / liga_away_avg;
                const home_defense_str = (homeLogs.reduce((s, l) => s + (l.name.toLowerCase().startsWith(homeTeam.toLowerCase()) ? l.awayScore : l.homeScore), 0) / homeLogs.length) / liga_away_avg;
                const away_defense_str = (awayLogs.reduce((s, l) => s + (l.name.toLowerCase().includes(awayTeam.toLowerCase()) ? (l.name.toLowerCase().startsWith(awayTeam.toLowerCase()) ? l.awayScore : l.homeScore) : l.homeScore), 0) / awayLogs.length) / liga_home_avg;

                const home_exp = home_attack_str * away_defense_str * liga_home_avg;
                const away_exp = away_attack_str * home_defense_str * liga_away_avg;
                
                const lambda3 = Math.sqrt(home_exp * away_exp) * lambda3Corr;
                const lambda1 = home_exp - lambda3;
                const lambda2 = away_exp - lambda3;
                if (lambda1 < 0 || lambda2 < 0) return { error: "Negatív lambda érték, a korreláció túl erős." };

                let generativeProbs = { homeProb: 0, drawProb: 0, awayProb: 0, over15Prob: 0, over25Prob: 0, bttsProb: 0 };
                let topScores = [];
                let totalProb = 0;

                for (let i = 0; i < 7; i++) {
                    for (let j = 0; j < 7; j++) {
                        const prob = this._bivariantPoisson(i, j, lambda1, lambda2, lambda3) * this._tau(i, j, rho);
                        totalProb += prob;
                        topScores.push({ score: `${i}-${j}`, probability: prob });
                    }
                }
                
                topScores.forEach(s => s.probability /= totalProb);
                
                topScores.forEach(s => {
                    const [i, j] = s.score.split('-').map(Number);
                    if (i > j) generativeProbs.homeProb += s.probability;
                    else if (j > i) generativeProbs.awayProb += s.probability;
                    else generativeProbs.drawProb += s.probability;
                    if (i + j > 1.5) generativeProbs.over15Prob += s.probability;
                    if (i + j > 2.5) generativeProbs.over25Prob += s.probability;
                    if (i > 0 && j > 0) generativeProbs.bttsProb += s.probability;
                });
                
                const relevantLogs = [...new Set([...homeLogs, ...awayLogs])];
                const empiricalProbs = {
                    homeProb: relevantLogs.length > 0 ? relevantLogs.filter(l => l.homeScore > l.awayScore).length / relevantLogs.length : 0,
                    drawProb: relevantLogs.length > 0 ? relevantLogs.filter(l => l.homeScore === l.awayScore).length / relevantLogs.length : 0,
                    awayProb: relevantLogs.length > 0 ? relevantLogs.filter(l => l.homeScore < l.awayScore).length / relevantLogs.length : 0,
                    over15Prob: relevantLogs.length > 0 ? relevantLogs.filter(l => l.homeScore + l.awayScore > 1.5).length / relevantLogs.length : 0,
                    over25Prob: relevantLogs.length > 0 ? relevantLogs.filter(l => l.homeScore + l.awayScore > 2.5).length / relevantLogs.length : 0,
                    bttsProb: relevantLogs.length > 0 ? relevantLogs.filter(l => l.homeScore > 0 && l.awayScore > 0).length / relevantLogs.length : 0
                };
                
                const finalProbs = {};
                for (const key in generativeProbs) {
                    finalProbs[key] = (1 - mixtureRatio) * generativeProbs[key] + mixtureRatio * empiricalProbs[key];
                }

                topScores.sort((a, b) => b.probability - a.probability);
                
                return {
                    strengths: { home_attack_str, away_attack_str, home_defense_str, away_defense_str },
                    params: { lambda1, lambda2, lambda3, rho },
                    probs: finalProbs,
                    topScores: topScores.slice(0, 3)
                };
            }
        },

        ADVERSARIAL_CHECKER: {
            run(bestTip) {
                if (!bestTip || !bestTip.value) return null;
                if (bestTip.prob < 0.3 && bestTip.value > 1.0) { 
                    return { message: `Extrém magas érték (${(bestTip.value*100).toFixed(0)}%) egy alacsony valószínűségű kimenetelen. Ez anomáliára utalhat.` };
                }
                return null;
            }
        },

        DYNAMIC_MARGIN: {
            run(probs) {
                const uncertainty = 1 - Math.max(probs.homeProb, probs.drawProb, probs.awayProb);
                const suggestedMargin = 0.02 + (uncertainty * 0.1);
                return { suggestedMargin: Math.min(suggestedMargin, 0.15) };
            }
        },

        DRIFT_MONITOR: {
            run() {
                if (logs.length < 40) return { message: "Nincs elég adat a drift elemzéshez (min. 40 meccs).", level: 'info' };
                const recentLogs = logs.slice(0, 20);
                const historicalLogs = logs.slice(20);
                const calcAvgGoals = (logSet) => logSet.reduce((sum, l) => sum + l.homeScore + l.awayScore, 0) / logSet.length;
                const drift = (calcAvgGoals(recentLogs) - calcAvgGoals(historicalLogs)) / calcAvgGoals(historicalLogs);
                if (Math.abs(drift) > 0.20) {
                     return { message: `Figyelem: Jelentős trendváltozás (${(drift*100).toFixed(0)}%) a gólokban!`, level: 'warning' };
                }
                return { message: "Nem észlelhető jelentős trendváltozás.", level: 'success' };
            }
        },

        AUTO_FIT: {
            // Refined two-stage (coarse-to-fine) auto-fit
            run(dataSource) {
                if (dataSource.length < 20) return { error: `Az automatikus illesztéshez legalább 20 meccs szükséges.`};

                const calculateError = (modelProbs, empiricalProbs) => {
                    return Math.pow(modelProbs.home - empiricalProbs.home, 2) + 
                           Math.pow(modelProbs.draw - empiricalProbs.draw, 2) + 
                           Math.pow(modelProbs.over25 - empiricalProbs.over25, 2);
                };

                const getAggregateProbs = (rho, l3c) => {
                    let modelProbs = { home: 0, draw: 0, over25: 0 };
                    let count = 0;
                    for(const log of dataSource) {
                        const [h_team, a_team] = log.name.split(' - ');
                        if (!h_team || !a_team) continue;
                        const res = AI_SYSTEM.GENERATIVE_CORE.run(h_team, a_team, rho, l3c, 0, dataSource);
                        if(res && !res.error) {
                            modelProbs.home += res.probs.homeProb;
                            modelProbs.draw += res.probs.drawProb;
                            modelProbs.over25 += res.probs.over25Prob;
                            count++;
                        }
                    }
                    if (count > 0) {
                        modelProbs.home /= count;
                        modelProbs.draw /= count;
                        modelProbs.over25 /= count;
                    }
                    return modelProbs;
                };

                const empirical = {
                    home: dataSource.filter(l=>l.homeScore > l.awayScore).length / dataSource.length,
                    draw: dataSource.filter(l=>l.homeScore === l.awayScore).length / dataSource.length,
                    over25: dataSource.filter(l=>l.homeScore + l.awayScore > 2.5).length / dataSource.length
                };

                // Stage 1: Coarse search
                let coarseBestParams = { rho: 0, lambda3Corr: 0 };
                let minError = Infinity;
                for (let rho = -0.5; rho <= 0.5; rho += 0.1) {
                    for (let l3c = 0; l3c <= 0.5; l3c += 0.1) {
                        const modelProbs = getAggregateProbs(rho, l3c);
                        const error = calculateError(modelProbs, empirical);
                        if (error < minError) {
                            minError = error;
                            coarseBestParams = { rho, lambda3Corr: l3c };
                        }
                    }
                }

                // Stage 2: Fine search around the best coarse parameters
                let fineBestParams = coarseBestParams;
                const searchRadius = 0.05;
                const fineStep = 0.01;
                const rhoMin = Math.max(-0.5, coarseBestParams.rho - searchRadius);
                const rhoMax = Math.min(0.5, coarseBestParams.rho + searchRadius);
                const l3cMin = Math.max(0, coarseBestParams.lambda3Corr - searchRadius);
                const l3cMax = Math.min(0.5, coarseBestParams.lambda3Corr + searchRadius);

                for (let rho = rhoMin; rho <= rhoMax; rho += fineStep) {
                    for (let l3c = l3cMin; l3c <= l3cMax; l3c += fineStep) {
                         const modelProbs = getAggregateProbs(rho, l3c);
                         const error = calculateError(modelProbs, empirical);
                         if (error < minError) {
                            minError = error;
                            fineBestParams = { rho, lambda3Corr: l3c };
                        }
                    }
                }
                
                return fineBestParams;
            }
        }
    };

    // --- MAIN APP LOGIC AND UI FUNCTIONS ---
    const saveToLocalStorage = () => {
        localStorage.setItem('vsportAdminLogs', JSON.stringify(logs));
        localStorage.setItem('vsportAdminPredictions', JSON.stringify(predictionsLog));
    };

    const loadFromLocalStorage = () => {
        const storedLogs = localStorage.getItem('vsportAdminLogs');
        const storedPredictions = localStorage.getItem('vsportAdminPredictions');
        if (storedLogs) {
            logs = JSON.parse(storedLogs);
        } else {
            logs = initialLogs; // Load sample data if nothing is in storage
        }
        if (storedPredictions) {
            predictionsLog = JSON.parse(storedPredictions);
        }
        renderLogs();
    };
    
    const renderLogs = () => {
        if (!logListDiv) return;
        logListDiv.innerHTML = logs.slice(0, 10).map(log => `
            <div class="outcome-${log.outcome} p-3 rounded-lg shadow-sm flex items-center justify-between transition card-hover text-sm">
                <div class="font-semibold text-slate-700">${log.name}</div>
                <div class="flex items-center gap-4">
                    <div class="font-bold text-slate-800 text-lg">${log.homeScore} - ${log.awayScore}</div>
                    <button data-id="${log.id}" class="delete-log-btn text-red-500 hover:text-red-700 font-bold text-xl">&times;</button>
                </div>
            </div>
        `).join('');
    };

    const runAIAnalysis = () => {
        const homeTeam = homeTeamInput.value.trim();
        const awayTeam = awayTeamInput.value.trim();
        const homeOdd = parseFloat(homeOddInput.value.replace(',', '.'));
        const drawOdd = parseFloat(drawOddInput.value.replace(',', '.'));
        const awayOdd = parseFloat(awayOddInput.value.replace(',', '.'));
        const rho = parseFloat(rhoSlider.value);
        const lambda3Corr = parseFloat(lambda3Slider.value);
        const mixtureRatio = parseFloat(mixtureSlider.value);
        // Read odds from new, specific input fields
        const over25Odd = parseFloat(document.getElementById('over-25-odd-input').value.replace(',', '.'));
        const under25Odd = parseFloat(document.getElementById('under-25-odd-input').value.replace(',', '.'));
        const bttsYesOdd = parseFloat(document.getElementById('btts-yes-odd-input').value.replace(',', '.'));
        const bttsNoOdd = parseFloat(document.getElementById('btts-no-odd-input').value.replace(',', '.'));
        
        if (!homeTeam || !awayTeam || isNaN(homeOdd) || isNaN(drawOdd) || isNaN(awayOdd)) {
            aiResultDiv.innerHTML = '<span class="text-gray-400">Add meg a csapatneveket és a 1X2 oddsokat!</span>'; return;
        }
        
        aiResultDiv.innerHTML = `<div class="p-4"><div class="flex items-center justify-center space-x-2 mt-2"><div class="loader"></div><span class="text-sm text-gray-400">Számítás...</span></div></div>`;

        setTimeout(() => {
            const result = AI_SYSTEM.GENERATIVE_CORE.run(homeTeam, awayTeam, rho, lambda3Corr, mixtureRatio);

            if (result.error) {
                aiResultDiv.innerHTML = `<div class="p-4 text-center text-red-400 font-semibold">${result.error}</div>`;
                return;
            }

            const potentialTips = [
                { text: 'Hazai győzelem', prob: result.probs.homeProb, odds: homeOdd },
                { text: 'Döntetlen', prob: result.probs.drawProb, odds: drawOdd },
                { text: 'Vendég győzelem', prob: result.probs.awayProb, odds: awayOdd },
                { text: 'Több mint 2.5 gól', prob: result.probs.over25Prob, odds: over25Odd },
                { text: 'Kevesebb mint 2.5 gól', prob: 1 - result.probs.over25Prob, odds: under25Odd },
                { text: 'Mindkét csapat szerez gólt', prob: result.probs.bttsProb, odds: bttsYesOdd },
                { text: 'Mindkét csapat nem szerez gólt', prob: 1 - result.probs.bttsProb, odds: bttsNoOdd },
                { text: 'Több mint 1.5 gól', prob: result.probs.over15Prob },
                { text: 'Kevesebb mint 1.5 gól', prob: 1 - result.probs.over15Prob }
            ];

            const rankedTips = potentialTips.map(tip => {
                const value = tip.odds && !isNaN(tip.odds) ? (tip.prob * tip.odds) - 1 : 0;
                const risk = 1 - tip.prob;
                const score = (tip.prob * (1 + value)) / (1 + risk); 
                const kelly = tip.odds && !isNaN(tip.odds) ? ((tip.prob * (tip.odds - 1)) - (1 - tip.prob)) / (tip.odds - 1) : 0;
                return { ...tip, value, kelly, score };
            }).sort((a, b) => b.score - a.score);

            const portfolio = buildPortfolio(rankedTips);

            const adversarialWarning = AI_SYSTEM.ADVERSARIAL_CHECKER.run(rankedTips[0]);
            const dynamicMargin = AI_SYSTEM.DYNAMIC_MARGIN.run(result.probs);
            
            const probToPercent = (p) => `${(p * 100).toFixed(1)}%`;
            
            const cardHTML = `<div class="p-4 poisson-card rounded-lg text-left space-y-4">
                    ${adversarialWarning ? `<div class="p-3 bg-red-500/20 border border-red-500 rounded-lg text-center"><p class="text-sm font-bold text-red-300">Kockázati Figyelmeztetés</p><p class="text-xs text-red-400 mt-1">${adversarialWarning.message}</p></div>` : ''}
                    <div>
                        <h4 class="font-bold text-sky-300 mb-2">Bemeneti Erősségek</h4>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-center text-sm">
                            <div class="bg-gray-800 p-2 rounded-md"><p class="text-xs text-gray-400">${homeTeam} Támadó</p><p class="font-bold text-white">${result.strengths.home_attack_str.toFixed(2)}</p></div>
                            <div class="bg-gray-800 p-2 rounded-md"><p class="text-xs text-gray-400">${homeTeam} Védekező</p><p class="font-bold text-white">${result.strengths.home_defense_str.toFixed(2)}</p></div>
                            <div class="bg-gray-800 p-2 rounded-md"><p class="text-xs text-gray-400">${awayTeam} Támadó</p><p class="font-bold text-white">${result.strengths.away_attack_str.toFixed(2)}</p></div>
                            <div class="bg-gray-800 p-2 rounded-md"><p class="text-xs text-gray-400">${awayTeam} Védekező</p><p class="font-bold text-white">${result.strengths.away_defense_str.toFixed(2)}</p></div>
                        </div>
                    </div>
                     <div>
                        <h4 class="font-bold text-sky-300 mb-2">Piaci Valószínűségek (${(mixtureRatio*100).toFixed(0)}% Preset Boost)</h4>
                          <div class="grid grid-cols-3 gap-2 text-center text-sm">
                              <div class="bg-gray-900 p-2 rounded-md flex flex-col justify-center items-center"><p class="text-xs text-gray-400">Hazai</p><p class="font-bold text-white">${probToPercent(result.probs.homeProb)}</p></div>
                              <div class="bg-gray-900 p-2 rounded-md flex flex-col justify-center items-center"><p class="text-xs text-gray-400">Döntetlen</p><p class="font-bold text-white">${probToPercent(result.probs.drawProb)}</p></div>
                              <div class="bg-gray-900 p-2 rounded-md flex flex-col justify-center items-center"><p class="text-xs text-gray-400">Vendég</p><p class="font-bold text-white">${probToPercent(result.probs.awayProb)}</p></div>
                          </div>
                    </div>
                    <div>
                        <h4 class="font-bold text-sky-300 mb-2">Kockázatkezelés & Dinamikus Margin</h4>
                        <div class="bg-gray-900/50 p-3 rounded-lg text-center text-sm">
                            <p>Javasolt alap margin: <span class="font-bold text-sky-300">${(dynamicMargin.suggestedMargin*100).toFixed(1)}%</span></p>
                        </div>
                    </div>
                     <div>
                        <h4 class="text-md font-semibold text-sky-300 mb-2">Explainability & Audit</h4>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="run-cf-sim" class="w-full bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg btn-hover text-sm hover:bg-indigo-700">Kontrafaktuális</button>
                            <button id="run-sensitivity-sim" class="w-full bg-indigo-700 text-white font-bold py-2 px-3 rounded-lg btn-hover text-sm hover:bg-indigo-800">Érzékenység</button>
                        </div>
                        <button id="run-mc-sim" class="w-full bg-purple-600 text-white font-bold py-2 px-3 rounded-lg btn-hover text-sm hover:bg-purple-700 mt-2">Monte Carlo Vizualizáció</button>
                        <canvas id="heatmap-canvas" class="mt-2 rounded-lg bg-gray-900/50" width="400" height="400" style="display:none;"></canvas>
                    </div>
                    <div>
                        <h4 class="text-md font-semibold text-sky-300 mb-1">Ajánlott Diverzifikált Portfólió</h4>
                        <div class="space-y-1">
                            ${portfolio.map((tip, index) => `
                                <div class="bg-gray-900 rounded-md p-3 text-center ${index === 0 ? 'border-2 border-sky-400' : ''}">
                                    <p class="text-md font-bold text-white">${tip.text}</p>
                                    <div class="text-xs text-sky-300 flex justify-center items-center gap-x-2 flex-wrap">
                                        <span>P: ${probToPercent(tip.prob)}</span> 
                                        ${tip.value > 0.01 ? `<span>| Érték: <span class="text-green-400">+${(tip.value*100).toFixed(0)}%</span></span>` : ''}
                                        ${tip.kelly > 0 ? `<span>| Kelly: <span class="text-yellow-400">${(tip.kelly*100).toFixed(1)}%</span></span>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="p-3 bg-gray-600 rounded-lg text-left mt-4">
                        <h4 class="font-bold text-gray-300 text-sm uppercase tracking-wider mb-2">Eredmény rögzítése</h4>
                        <div class="flex items-center space-x-2">
                            <input type="number" placeholder="H" class="actual-home-score w-16 px-2 py-1 text-sm rounded-lg bg-gray-800 border border-gray-500 focus:ring-2 focus:ring-sky-400 text-white text-center">
                            <span class="text-gray-400">-</span>
                            <input type="number" placeholder="V" class="actual-away-score w-16 px-2 py-1 text-sm rounded-lg bg-gray-800 border border-gray-500 focus:ring-2 focus:ring-sky-400 text-white text-center">
                            <button class="save-result-btn ml-auto bg-purple-600 text-white font-semibold py-1 px-3 rounded-lg text-sm btn-hover hover:bg-purple-700">Mentés</button>
                        </div>
                        <div class="result-feedback text-center text-sm mt-2"></div>
                    </div>
                </div>`;
                
            aiResultDiv.innerHTML = cardHTML;

            const saveBtn = aiResultDiv.querySelector('.save-result-btn');
            if (saveBtn) {
                Object.assign(saveBtn.dataset, { 
                    homeTeam, 
                    awayTeam, 
                    homeOdd, drawOdd, awayOdd,
                    topPredictions: JSON.stringify(portfolio) // Save the final portfolio
                });
            }

            document.getElementById('run-mc-sim').addEventListener('click', () => {
                document.getElementById('heatmap-canvas').style.display = 'block';
                runMonteCarlo(result.params, document.getElementById('heatmap-canvas'));
            });
            document.getElementById('run-cf-sim').addEventListener('click', () => {
                runCounterfactual(homeTeam, awayTeam, rho, lambda3Corr, mixtureRatio, result.probs);
            });
            document.getElementById('run-sensitivity-sim').addEventListener('click', () => {
                 runSensitivityAnalysis(homeTeam, awayTeam, rho, lambda3Corr, mixtureRatio);
            });

        }, 100);
    };
    
    // New function to build a diversified portfolio
    const buildPortfolio = (allTips) => {
        const portfolio = [];
        let availableTips = [...allTips];

        const correlationPenalties = {
            'Hazai győzelem': { 'Több mint 2.5 gól': 0.15, 'Mindkét csapat szerez gólt': 0.10, 'Több mint 1.5 gól': 0.10 },
            'Vendég győzelem': { 'Több mint 2.5 gól': 0.15, 'Mindkét csapat szerez gólt': 0.10, 'Több mint 1.5 gól': 0.10 },
            'Több mint 2.5 gól': { 'Hazai győzelem': 0.15, 'Vendég győzelem': 0.15, 'Mindkét csapat szerez gólt': 0.25, 'Több mint 1.5 gól': 0.30 },
            'Mindkét csapat szerez gólt': { 'Hazai győzelem': 0.10, 'Vendég győzelem': 0.10, 'Több mint 2.5 gól': 0.25, 'Több mint 1.5 gól': 0.20 },
            'Több mint 1.5 gól': { 'Hazai győzelem': 0.10, 'Vendég győzelem': 0.10, 'Több mint 2.5 gól': 0.30, 'Mindkét csapat szerez gólt': 0.20 }
        };

        while (portfolio.length < 3 && availableTips.length > 0) {
            availableTips.sort((a, b) => b.score - a.score);
            const bestTip = availableTips[0];
            portfolio.push(bestTip);
            availableTips = availableTips.filter(tip => tip.text !== bestTip.text);

            // Apply penalties for the next iteration
            const penalties = correlationPenalties[bestTip.text];
            if (penalties) {
                availableTips.forEach(tip => {
                    if (penalties[tip.text]) {
                        tip.score *= (1 - penalties[tip.text]);
                    }
                });
            }
        }
        return portfolio;
    };

    const runAutofit = (dataSource) => {
        if (dataSource.length < 20) {
            autofitStatus.textContent = `Auto-Fit: Túl kevés adat (${dataSource.length}/20).`;
            autofitStatus.className = `text-xs font-semibold h-4 mt-1 text-center text-yellow-400`;
            return;
        }
        autofitStatus.textContent = "Finomhangolás fut... (ez eltarthat egy ideig)";
        autofitStatus.className = `text-xs font-semibold h-4 mt-1 text-center text-sky-400`;
        setTimeout(() => {
            const bestParams = AI_SYSTEM.AUTO_FIT.run(dataSource);
            if(bestParams && !bestParams.error){
                rhoSlider.value = bestParams.rho.toFixed(2);
                lambda3Slider.value = bestParams.lambda3Corr.toFixed(2);
                rhoValue.textContent = bestParams.rho.toFixed(2);
                lambda3Value.textContent = bestParams.lambda3Corr.toFixed(2);
                autofitStatus.textContent = `Paraméterek frissítve! ρ=${bestParams.rho.toFixed(2)}, λ3c=${bestParams.lambda3Corr.toFixed(2)}`;
                autofitStatus.className = `text-xs font-semibold h-4 mt-1 text-center text-green-400`;
                runAIAnalysis();
            } else {
                 autofitStatus.textContent = bestParams.error || "Hiba az illesztés során.";
                 autofitStatus.className = `text-xs font-semibold h-4 mt-1 text-center text-red-400`;
            }
        }, 100);
    };

    const checkPrediction = (predictionText, homeScore, awayScore) => {
        switch (predictionText) {
            case 'Hazai győzelem': return homeScore > awayScore;
            case 'Döntetlen': return homeScore === awayScore;
            case 'Vendég győzelem': return homeScore < awayScore;
            case 'Több mint 2.5 gól': return homeScore + awayScore > 2.5;
            case 'Kevesebb mint 2.5 gól': return homeScore + awayScore < 2.5;
            case 'Mindkét csapat szerez gólt': return homeScore > 0 && awayScore > 0;
            case 'Mindkét csapat nem szerez gólt': return homeScore === 0 || awayScore === 0;
            case 'Több mint 1.5 gól': return homeScore + awayScore > 1.5;
            case 'Kevesebb mint 1.5 gól': return homeScore + awayScore < 1.5;
            default: return false;
        }
    };

    const renderStatistics = () => {
        modalTitle.textContent = "Tipp Statisztika";
        if (predictionsLog.length === 0) {
            modalContent.innerHTML = "<p>Nincsenek rögzített tippek.</p>";
            return;
        }

        const totalTips = predictionsLog.length;
        const correctTips = predictionsLog.filter(p => p.correct).length;
        const totalMainTips = predictionsLog.filter(p => p.isMainTip).length;
        const correctMainTips = predictionsLog.filter(p => p.isMainTip && p.correct).length;
        
        const accuracy = totalTips > 0 ? (correctTips / totalTips * 100).toFixed(1) : 0;
        const mainTipAccuracy = totalMainTips > 0 ? (correctMainTips / totalMainTips * 100).toFixed(1) : 0;

        modalContent.innerHTML = `
            <div class="space-y-4 text-sm">
                <div class="grid grid-cols-2 gap-4 text-center">
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <p class="text-gray-400">Fő Tipp Pontosság</p>
                        <p class="text-2xl font-bold text-sky-300">${mainTipAccuracy}%</p>
                        <p class="text-xs text-gray-500">${correctMainTips} / ${totalMainTips}</p>
                    </div>
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <p class="text-gray-400">Teljes Pontosság</p>
                        <p class="text-2xl font-bold text-white">${accuracy}%</p>
                        <p class="text-xs text-gray-500">${correctTips} / ${totalTips}</p>
                    </div>
                </div>
                <div>
                    <h4 class="font-bold text-sky-300 mb-2">Legutóbbi 5 Fő Tipp</h4>
                    <ul class="space-y-2">
                        ${predictionsLog.filter(p => p.isMainTip).slice(0, 5).map(p => `
                            <li class="flex justify-between items-center bg-gray-900 p-2 rounded-md">
                                <div>
                                    <p class="font-semibold">${p.teams}</p>
                                    <p class="text-xs text-gray-400">${p.predicted} (${p.actualScore})</p>
                                </div>
                                ${p.correct ? '<span class="text-green-400 font-bold">✓</span>' : '<span class="text-red-400 font-bold">✗</span>'}
                            </li>
                        `).join('')}
                    </ul>
                </div>
            </div>
        `;
    };
    
    const runMonteCarlo = (params, canvas) => {
        const { lambda1, lambda2, lambda3, rho } = params;
        const gridSize = 7;
        let scoreGrid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
        let totalProb = 0;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const prob = AI_SYSTEM.GENERATIVE_CORE._bivariantPoisson(i, j, lambda1, lambda2, lambda3) * AI_SYSTEM.GENERATIVE_CORE._tau(i, j, rho);
                scoreGrid[i][j] = prob;
                totalProb += prob;
            }
        }
        scoreGrid = scoreGrid.map(row => row.map(cell => cell / totalProb));
        drawHeatmap(scoreGrid, canvas);
    };

    const drawHeatmap = (grid, canvas) => {
        const ctx = canvas.getContext('2d');
        const gridSize = grid.length;
        const cellSize = canvas.width / gridSize;
        const maxProb = Math.max(...grid.flat());

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `${Math.floor(cellSize / 3.5)}px Inter`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const prob = grid[j][i];
                const opacity = prob / maxProb;
                ctx.fillStyle = `rgba(56, 189, 248, ${opacity})`;
                ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                ctx.fillStyle = opacity > 0.5 ? '#FFFFFF' : '#E0F2FE';
                ctx.fillText((prob * 100).toFixed(1) + '%', i * cellSize + cellSize / 2, j * cellSize + cellSize / 2);
            }
        }
    };
    
    const runCounterfactual = (homeTeam, awayTeam, rho, l3c, mix, baseProbs) => {
        modalTitle.textContent = "Kontrafaktuális Szimuláció";
        const tempLogs = JSON.parse(JSON.stringify(logs));
        const homeLogIndex = tempLogs.findIndex(l => l.name.toLowerCase().includes(homeTeam.toLowerCase()));
        if (homeLogIndex === -1) {
            modalContent.innerHTML = "Nem található adat a kontrafaktuális elemzéshez.";
            modalContainer.classList.remove('hidden');
            return;
        }
        
        const originalScore = tempLogs[homeLogIndex].homeScore;
        tempLogs[homeLogIndex].homeScore += 2;
        const cfResult = AI_SYSTEM.GENERATIVE_CORE.run(homeTeam, awayTeam, rho, l3c, mix, tempLogs);
        tempLogs[homeLogIndex].homeScore = originalScore; 
        
        const probToPercent = (p) => (p * 100).toFixed(1) + '%';
        const diff = (newP, oldP) => {
            const d = (newP - oldP) * 100;
            return d > 0 ? `<span class="text-green-400">(+${d.toFixed(1)}%)</span>` : `<span class="text-red-400">(${d.toFixed(1)}%)</span>`;
        };

        modalContent.innerHTML = `
            <p class="text-sm">Ez a szimuláció megmutatja, hogyan változnának a valószínűségek, ha a(z) <strong>${homeTeam}</strong> formája hirtelen 2 góllal javulna egy korábbi meccs alapján.</p>
            <table class="w-full text-left text-sm">
                <thead><tr class="border-b border-gray-600"><th class="p-2">Kimenetel</th><th class="p-2">Eredeti</th><th class="p-2">Szimulált</th></tr></thead>
                <tbody>
                    <tr><td class="p-2 font-semibold">Hazai</td><td class="p-2">${probToPercent(baseProbs.homeProb)}</td><td class="p-2">${probToPercent(cfResult.probs.homeProb)} ${diff(cfResult.probs.homeProb, baseProbs.homeProb)}</td></tr>
                    <tr><td class="p-2 font-semibold">Döntetlen</td><td class="p-2">${probToPercent(baseProbs.drawProb)}</td><td class="p-2">${probToPercent(cfResult.probs.drawProb)} ${diff(cfResult.probs.drawProb, baseProbs.drawProb)}</td></tr>
                    <tr><td class="p-2 font-semibold">Vendég</td><td class="p-2">${probToPercent(baseProbs.awayProb)}</td><td class="p-2">${probToPercent(cfResult.probs.awayProb)} ${diff(cfResult.probs.awayProb, baseProbs.awayProb)}</td></tr>
                </tbody>
            </table>
        `;
        modalContainer.classList.remove('hidden');
    };
    
    const runSensitivityAnalysis = (homeTeam, awayTeam, rho, l3c, mix) => {
        modalTitle.textContent = "Érzékenységvizsgálat";
        let resultsHTML = `<p class="text-sm">Ez a táblázat megmutatja, hogyan változik a hazai győzelem esélye a Dixon-Coles (ρ) paraméter módosításával.</p>
        <table class="w-full text-left text-sm mt-2">
            <thead><tr class="border-b border-gray-600"><th class="p-2">ρ Érték</th><th class="p-2">Hazai Győzelem Esélye</th></tr></thead>
            <tbody>`;
        
        for(let testRho = -0.5; testRho <= 0.5; testRho += 0.1) {
            const result = AI_SYSTEM.GENERATIVE_CORE.run(homeTeam, awayTeam, testRho, l3c, mix);
            if (result.error) continue;
            const isCurrent = Math.abs(testRho - rho) < 0.01;
            resultsHTML += `<tr class="${isCurrent ? 'bg-sky-800/50' : ''}">
                <td class="p-2 font-bold">${testRho.toFixed(1)} ${isCurrent ? '(Jelenlegi)' : ''}</td>
                <td class="p-2">${(result.probs.homeProb * 100).toFixed(1)}%</td>
            </tr>`;
        }
        resultsHTML += `</tbody></table>`;
        modalContent.innerHTML = resultsHTML;
        modalContainer.classList.remove('hidden');
    };


    // --- INITIALIZATION AND EVENT LISTENERS ---
    loadFromLocalStorage();

    document.querySelectorAll('.ai-input').forEach(input => {
        input.addEventListener('input', () => {
            clearTimeout(analysisTimeout);
            analysisTimeout = setTimeout(runAIAnalysis, 500);
        });
    });

    rhoSlider.addEventListener('input', () => { rhoValue.textContent = parseFloat(rhoSlider.value).toFixed(2); });
    lambda3Slider.addEventListener('input', () => { lambda3Value.textContent = parseFloat(lambda3Slider.value).toFixed(2); });
    mixtureSlider.addEventListener('input', () => { mixtureValue.textContent = `${(parseFloat(mixtureSlider.value) * 100).toFixed(0)}%`; });
    marginSlider.addEventListener('input', () => { marginValue.textContent = `${(parseFloat(marginSlider.value) * 100).toFixed(1)}%`; });

    autofitFullBtn.addEventListener('click', () => runAutofit(logs));
    autofitRecentBtn.addEventListener('click', () => runAutofit(logs.slice(0, 50)));

    driftCheckBtn.addEventListener('click', () => {
        const result = AI_SYSTEM.DRIFT_MONITOR.run();
        const color = result.level === 'warning' ? 'text-yellow-400' : result.level === 'success' ? 'text-green-400' : 'text-gray-400';
        autofitStatus.className = `text-xs font-semibold h-4 mt-1 text-center ${color}`;
        autofitStatus.textContent = result.message;
        setTimeout(() => {
            autofitStatus.textContent = '';
            autofitStatus.className = `text-xs font-semibold h-4 mt-1 text-center`;
        }, 5000);
    });
    
    closeModalBtn.addEventListener('click', () => modalContainer.classList.add('hidden'));
    modalContainer.addEventListener('click', (e) => { if (e.target === modalContainer) modalContainer.classList.add('hidden'); });
    openStatsBtn.addEventListener('click', () => {
        renderStatistics();
        modalContainer.classList.remove('hidden');
    });

    aiResultDiv.addEventListener('click', e => {
        const btn = e.target.closest('.save-result-btn');
        if (btn && !btn.disabled) {
            const panel = btn.closest('.poisson-card');
            const actualHomeScore = parseInt(panel.querySelector('.actual-home-score').value, 10);
            const actualAwayScore = parseInt(panel.querySelector('.actual-away-score').value, 10);
            const feedbackDiv = panel.querySelector('.result-feedback');

            if (isNaN(actualHomeScore) || isNaN(actualAwayScore)) {
                feedbackDiv.innerHTML = `<span class="font-bold text-red-500">Kérlek add meg a valós végeredményt!</span>`;
                setTimeout(() => feedbackDiv.innerHTML = '', 3000);
                return;
            }

            const actualOutcome = (actualHomeScore > actualAwayScore) ? 'homeWin' : (actualAwayScore > actualHomeScore) ? 'awayWin' : 'draw';
            const newLog = { 
                id: Date.now(), 
                name: `${btn.dataset.homeTeam} - ${btn.dataset.awayTeam}`, 
                home: parseFloat(btn.dataset.homeOdd), 
                draw: parseFloat(btn.dataset.drawOdd), 
                away: parseFloat(btn.dataset.awayOdd), 
                homeScore: actualHomeScore, 
                awayScore: actualAwayScore, 
                outcome: actualOutcome
            };
            logs.unshift(newLog);
            
            const topPredictions = JSON.parse(btn.dataset.topPredictions || '[]');
            topPredictions.forEach((prediction, index) => {
                predictionsLog.push({
                    id: Date.now() + Math.random(),
                    teams: `${btn.dataset.homeTeam} - ${btn.dataset.awayTeam}`,
                    predicted: prediction.text,
                    isMainTip: index === 0,
                    actualScore: `${actualHomeScore}-${actualAwayScore}`,
                    correct: checkPrediction(prediction.text, actualHomeScore, actualAwayScore),
                });
            });
            
            saveToLocalStorage();
            renderLogs();
            feedbackDiv.innerHTML = `<span class="font-bold text-green-500">Eredmény rögzítve! Auto-Fit futtatása...</span>`;
            btn.disabled = true;
            panel.querySelectorAll('input').forEach(i => i.disabled = true);
            
            // Automatic adaptation after saving a result
            setTimeout(() => runAutofit(logs.slice(0, 50)), 500);
        }
    });

    logListDiv.addEventListener('click', e => {
        const btn = e.target.closest('.delete-log-btn');
        if (btn) {
            logs = logs.filter(l => l.id !== parseInt(btn.dataset.id));
            saveToLocalStorage();
            renderLogs();
        }
    });
});
</script>

</body>
</html>
